
# include("core.jl")

"""
    Aggregate{T,C1,C2}(molecules, coupling)
    Aggregate{T,C1,C2}(molecules)

Mutable stuct which purpose is to store important information about the whole system.

# Arguments
* `molecules`: Vector of molecules ([`Molecule`](@ref)).
* `coupling`: Matrix of couplings ``J_{nm}`` between molecules.
"""
mutable struct Aggregate{T<:Integer,C1<:ComputableType,C2<:ComputableType}
    molecules::Vector{Molecule{T,C1,C2}}
    coupling::Matrix{C1}
    function Aggregate{T,C1,C2}(
        molecules::Vector{Molecule{T,C1,C2}},
        coupling::Matrix{C1},
    ) where {T<:Integer,C1<:ComputableType,C2<:ComputableType}
        new(molecules, coupling)
    end
end

Aggregate(molecules::Vector{Molecule{T,C1,C2}}, coupling::Matrix{C1}) where {T,C1,C2} =
    Aggregate{T,C1,C2}(molecules, coupling)
Aggregate(molecules::Vector{Molecule{T,C1,C2}}) where {T,C1,C2} =
    Aggregate{T,C1,C2}(molecules, zeros(C1, (length(molecules) + 1, length(molecules) + 1)))

"""
    getNvib(agg)

Get maximum number of vibrational states of each molecule in the [`Aggregate`](@ref).

"""
function getNvib(
    agg::Aggregate{T,C1,C2},
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType}
    NvibMols = Array{Array{T,1},1}(undef, 0)
    for mol in agg.molecules
        push!(NvibMols, fill(mol.Nvib, length(mol.modes)))
    end
    return NvibMols
end

"""
    vibrationalIndices(agg)

Get all vibrational indices of the [`Aggregate`](@ref).

"""
function vibrationalIndices(
    agg::Aggregate{T,C1,C2},
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType}
    NvibMols = getNvib(agg)
    molLen = length(agg.molecules)
    NvibIndMols = Array{Array{Array{T,1},1},1}(undef, 0)
    for mol_i = 1:molLen
        push!(NvibIndMols, vibrationalIndices(NvibMols[mol_i]))
    end
    molNvib = map((vibInds) -> length(vibInds), NvibIndMols)
    molInds = vibrationalIndices(molNvib)
    aggInds = Array{Array{Array{T,1},1},1}(undef, 0)
    for molInd in molInds
        aggInd = Array{Array{T,1},1}(undef, 0)
        for mol_i = 1:molLen
            push!(aggInd, NvibIndMols[mol_i][molInd[mol_i]])
        end
        push!(aggInds, aggInd)
    end
    return aggInds
end

"""
    vibrationalIndices(agg; groundState = true)

Get all electronic indices of the [`Aggregate`](@ref).

# Arguments
* `agg`: Instance of [`Aggregate`](@ref).
* `groundState`: Option for allowing the ground electric state in local basis.
"""
function electronicIndices(
    agg::Aggregate{T,C1,C2};
    groundState = true,
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType}
    vibInds = Array{Array{T,1},1}(undef, 0)
    molCount = length(agg.molecules)
    currentInds = fill(1, (molCount))
    if groundState
        push!(vibInds, copy(currentInds))
    end
    for indPos = 1:molCount
        currentInds[indPos] += 1
        push!(vibInds, copy(currentInds))
        currentInds[indPos] -= 1
    end
    return vibInds
end

"""
    getIndices(agg; groundState = true)

Get all indices (electronic and vibrational) of the [`Aggregate`](@ref).

# Arguments
* `agg`: Instance of [`Aggregate`](@ref).
* `groundState`: Option for allowing the ground electric state in local basis.
"""
function getIndices(
    agg::Aggregate{T,C1,C2};
    groundState = true,
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType}
    vibInds = vibrationalIndices(agg)
    vibIndsLen = length(vibInds)
    elInds = electronicIndices(agg; groundState = groundState)
    elIndsLen = length(elInds)
    indices = Array{Array{Array{T,1} where T,1},1}(undef, 0)
    for el_i = 1:elIndsLen
        for vib_i = 1:vibIndsLen
            push!(indices, [elInds[el_i], vibInds[vib_i]])
        end
    end
    return indices
end

"""
    getVibIndices(agg; groundState = true)

Get pointers (integers) to the indices of the [`Aggregate`](@ref) separated by 
electronic states (e.g. [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]).

# Arguments
* `agg`: Instance of [`Aggregate`](@ref).
* `groundState`: Option for allowing the ground electric state in local basis.
"""
function getVibIndices(agg, aggIndices)
    aggIndLen = length(aggIndices)
    vibindices = Array{Array{Int,1},1}(undef, 0)
    elLen = length(agg.molecules) + 1
    for el_i = 1:elLen
        push!(vibindices, Array{Int,1}(undef, 0))
    end

    for I = 1:aggIndLen
        elind1, vibind1 = aggIndices[I]
        elOrder1 = OpenQuantumSystems.elIndOrder(elind1)
        push!(vibindices[elOrder1], I)
    end
    return vibindices
end

"""
    getFranckCondonFactors(agg, aggIndices; groundState = true)
    getFranckCondonFactors(agg; groundState = true)

Get Frack-Condon factors of the [`Aggregate`](@ref) in a form of matrix.

# Arguments
* `agg`: Instance of [`Aggregate`](@ref).
* `aggIndices`: Aggregate indices generated by [`getIndices`](@ref).
* `groundState`: Option for allowing the ground electric state in local basis.
"""
function getFranckCondonFactors(
    agg::Aggregate{T,C1,C2},
    aggIndices::Any;
    groundState::Bool = true,
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType}
    if aggIndices === nothing
        aggIndices = getIndices(agg; groundState = groundState)
    end
    aggIndLen = length(aggIndices)
    molLen = length(agg.molecules)
    FC = zeros(C2, (aggIndLen, aggIndLen))
    for I = 1:aggIndLen
        elind1, vibind1 = aggIndices[I]
        for J = 1:aggIndLen
            elind2, vibind2 = aggIndices[J]
            if elind1 == elind2
                if vibind1 == vibind2
                    FC[I, J] = 1.0
                end
            else
                fc = 1.0::C2
                for mi = 1:molLen
                    mol = agg.molecules[mi]
                    fc *=
                        getMolStateFC(mol, elind1[mi], vibind1[mi], elind2[mi], vibind2[mi])
                end
                FC[I, J] = fc
            end
        end
    end
    return FC
end

getFranckCondonFactors(
    agg::Aggregate{T,C1,C2};
    groundState::Bool = true,
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType} =
    getFranckCondonFactors(agg::Aggregate{T,C1,C2}, nothing; groundState = groundState)

"""
    getAggStateEnergy(agg, aggElState, aggVibState)

Get Hamiltonian of the [`Aggregate`](@ref) in a form of DenseOperator.

# Arguments
* `agg`: Instance of [`Aggregate`](@ref).
* `aggElState`: Aggregate electric state (e.g. [1, 1, 2]).
* `aggVibState`: Aggregate vibrational state (e.g. [[9, 1], [2, 5, 3], [10]]).
"""
function getAggStateEnergy(
    agg::Aggregate{T,C1,C2},
    aggElState::Vector{U},
    aggVibState::Vector{Vector{U}},
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType,U<:Integer}
    energy = 0.0::C1
    for mol_i = 1:length(agg.molecules)
        molElState = aggElState[mol_i]
        molVibState = aggVibState[mol_i]
        energy += getMolStateEnergy(agg.molecules[mol_i], molElState, molVibState)
    end
    return energy
end

function elIndOrder(elInd::Vector{T}) where {T<:Integer}
    len = length(elInd)
    ind = 1::T
    for i = 1:len
        ind += (elInd[i] - 1) * i
    end
    return ind
end

"""
    getAggHamiltonian(agg, aggIndices, 
    \tfranckCondonFactors; groundState = false, groundEnergy = false)
    getAggHamiltonian(agg, aggIndices; groundState = false, groundEnergy = false)
    getAggHamiltonian(agg; groundState = false, groundEnergy = false)

Get Hamiltonian of the [`Aggregate`](@ref) in a form of DenseOperator.

# Arguments
* `agg`: Instance of [`Aggregate`](@ref).
* `aggIndices`: Aggregate indices generated by [`getIndices`](@ref).
* `franckCondonFactors`: Franck-Condon factors generated by [`getFranckCondonFactors`](@ref).
* `groundState`: Option for allowing the ground electric state in local basis.
"""
function getAggHamiltonian(
    agg::Aggregate{T,C1,C2},
    aggIndices::Any,
    franckCondonFactors::Any;
    groundState::Bool = false,
    groundEnergy::Bool = false,
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType}
    if aggIndices === nothing
        aggIndices = getIndices(agg; groundState = groundState)
    end
    aggIndLen = length(aggIndices)
    molLen = length(agg.molecules)
    if franckCondonFactors === nothing
        franckCondonFactors = getFranckCondonFactors(agg, aggIndices)
    end
    Ham = zeros(C2, (aggIndLen, aggIndLen))
    for I = 1:aggIndLen
        elind1, vibind1 = aggIndices[I]
        elOrder1 = elIndOrder(elind1)
        for J = 1:aggIndLen
            elind2, vibind2 = aggIndices[J]
            elOrder2 = elIndOrder(elind2)
            if I == J
                Ham[I, J] = getAggStateEnergy(agg, elind1, vibind1)
            else
                if elind1 != elind2
                    Ham[I, J] = agg.coupling[elOrder1, elOrder2] * franckCondonFactors[I, J]
                end
            end
        end
    end
    if !groundEnergy
        E0 = Ham[1, 1]
        for I = 1:aggIndLen
            Ham[I, I] -= E0
        end
    end
    b = GenericBasis([aggIndLen])
    return DenseOperator(b, b, Ham)
end

getAggHamiltonian(
    agg::Aggregate{T,C1,C2};
    groundState::Bool = false,
    groundEnergy::Bool = false,
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType} = getAggHamiltonian(
    agg::Aggregate{T,C1,C2},
    nothing,
    nothing;
    groundState = groundState,
    groundEnergy = groundEnergy,
)

getAggHamiltonian(
    agg::Aggregate{T,C1,C2},
    aggIndices::Any;
    groundState::Bool = false,
    groundEnergy::Bool = false,
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType} = getAggHamiltonian(
    agg::Aggregate{T,C1,C2},
    aggIndices,
    nothing;
    groundState = groundState,
    groundEnergy = groundEnergy,
)

"""
    getAggHamiltonianSystem(agg; groundState = false)

Get Hamiltonian of the system, ``H_S``.

# Arguments
* `agg`: Instance of [`Aggregate`](@ref).
* `groundState`: Option for allowing the ground electric state in local basis.
"""
function getAggHamiltonianSystem(
    agg::Aggregate{T,C1,C2};
    groundState::Bool = false,
    groundEnergy::Bool = true,
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType}
    molLen = length(agg.molecules)
    if groundState
        Ham_sys = zeros(C2, (molLen + 1, molLen + 1))
    else
        Ham_sys = zeros(C2, (molLen, molLen))
    end
    elInds = electronicIndices(agg; groundState = groundState)
    E_agg = zeros(C1, (2, molLen))
    E_agg[1, :] = map(mol -> mol.E[1], agg.molecules)
    E_agg[2, :] = map(mol -> mol.E[2], agg.molecules)
    for elInd in elInds
        ind = OpenQuantumSystems.elIndOrder(elInd)
        if !groundState
            ind -= 1
        end
        E_state = 0
        for mol_i = 1:molLen
            E_state += E_agg[elInd[mol_i], mol_i]
        end
        Ham_sys[ind, ind] = E_state
    end

    if groundState
        Ham_sys[:, :] += agg.coupling[:, :]
    else
        Ham_sys[:, :] += agg.coupling[2:molLen+1, 2:molLen+1]
    end
    if !groundEnergy
        E0 = Ham_sys[1, 1]
        for i = 1:size(Ham_sys, 1)
            Ham_sys[i, i] -= E0
        end
    end
    b = GenericBasis([size(Ham_sys, 1)])
    return DenseOperator(b, b, Ham_sys)
end


"""
    getAggHamiltonianBath(agg)

Get Hamiltonian of the bath, ``H_B``.

"""
function getAggHamiltonianBath(
    agg::Aggregate{T,C1,C2},
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType}
    molLen = length(agg.molecules)
    vibInds = vibrationalIndices(agg)
    vibIndsLen = length(vibInds)
    Ham_bath = zeros(C2, (vibIndsLen, vibIndsLen))

    agg2 = deepcopy(agg)
    for mol_i in molLen
        agg2.molecules[mol_i].E[1] = 0.0
    end
    elind = fill(1, (molLen + 1))
    for I = 1:vibIndsLen
        vibind = vibInds[I]
        Ham_bath[I, I] = getAggStateEnergy(agg, elind, vibind)
    end
    b = GenericBasis([vibIndsLen])
    return DenseOperator(b, b, Ham_bath)
end


"""
    getAggHamSysBath(agg, aggIndices; groundState = false, groundEnergy = false)

Get Hamiltonian of the system and of the bath, ``H_S + H_B`` by generating Hamiltonian 
with zero [`Mode`](@ref) shifts.

# Arguments
* `agg`: Instance of [`Aggregate`](@ref).
* `aggIndices`: Aggregate indices generated by [`getIndices`](@ref).
* `franckCondonFactors`: Franck-Condon factors generated by [`getFranckCondonFactors`](@ref).
* `groundState`: Option for allowing the ground electric state in local basis.
"""
function getAggHamSysBath(
    agg::Aggregate{T,C1,C2},
    aggIndices::Any;
    groundState::Bool = false,
    groundEnergy::Bool = false,
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType}
    agg2 = deepcopy(agg)
    for mol_i = 1:length(agg2.molecules)
        mol = agg2.molecules[mol_i]
        for mode in mol.modes
            mode.shift = typeof(mode.shift)(0)
        end
        mol = updateMolecule(mol)
        agg2.molecules[mol_i] = mol
    end

    if aggIndices === nothing
        aggIndices = getIndices(agg2; groundState = groundState)
    end
    aggIndLen = length(aggIndices)
    molLen = length(agg.molecules)
    franckCondonFactors = getFranckCondonFactors(agg2, aggIndices)
    getAggHamiltonian(
        agg2,
        aggIndices;
        groundState = groundState,
        groundEnergy = groundEnergy,
    )
end

"""
    getAggHamSysBath2(agg, aggIndices; groundState = false, groundEnergy = false)

Get Hamiltonian of the system and of the bath, ``H_S + H_B`` by multiplication Hilbert 
spaces of the system and of the bath.

# Arguments
* `agg`: Instance of [`Aggregate`](@ref).
* `aggIndices`: Aggregate indices generated by [`getIndices`](@ref).
* `franckCondonFactors`: Franck-Condon factors generated by [`getFranckCondonFactors`](@ref).
* `groundState`: Option for allowing the ground electric state in local basis.
"""
function getAggHamSysBath2(
    agg::Aggregate{T,C1,C2},
    aggIndices::Any;
    groundState::Bool = false,
    groundEnergy::Bool = false,
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType}
    if aggIndices === nothing
        aggIndices = getIndices(agg; groundState = groundState)
    end
    aggIndLen = length(aggIndices)
    Ham_bath = getAggHamiltonianBath(agg)
    Ham_sys = getAggHamiltonianSystem(agg; groundState = groundState, groundEnergy = groundEnergy)
    b = GenericBasis([aggIndLen])
    b_sys = GenericBasis([size(Ham_sys, 1)])
    b_bath = GenericBasis([size(Ham_bath, 1)])

    Ham_S =
        tensor(OneDenseOperator(b_bath), Ham_sys) +
        tensor(Ham_bath, OneDenseOperator(b_sys))

    if !groundEnergy
        E0 = Ham_S.data[1, 1]
        for I = 1:aggIndLen
            Ham_S.data[I, I] -= E0
        end
    end
    return DenseOperator(b, b, Ham_S.data)
end

"""
    getAggHamiltonianInteraction(agg, aggIndices, franckCondonFactors; 
    \tgroundState = false, groundEnergy = false)
    getAggHamiltonianInteraction(agg, aggIndices; groundState = false, groundEnergy = false)
    getAggHamiltonianInteraction(agg; groundState = false, groundEnergy = false)

Get interation Hamiltonian of the [`Aggregate`](@ref), ``H_I`` by substracting 
Hamiltonian and Hamiltonian of the systems and of the bath, ``H - H_S - H_B``.

# Arguments
* `agg`: Instance of [`Aggregate`](@ref).
* `aggIndices`: Aggregate indices generated by [`getIndices`](@ref).
* `franckCondonFactors`: Franck-Condon factors generated by [`getFranckCondonFactors`](@ref).
* `groundState`: Option for allowing the ground electric state in local basis.
"""
function getAggHamiltonianInteraction(
    agg::Aggregate{T,C1,C2},
    aggIndices::Any,
    franckCondonFactors::Any;
    groundState::Bool = false,
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType}
    if aggIndices === nothing
        aggIndices = getIndices(agg; groundState = groundState)
    end
    aggIndLen = length(aggIndices)
    molLen = length(agg.molecules)
    if franckCondonFactors === nothing
        franckCondonFactors = getFranckCondonFactors(agg, aggIndices)
    end
    Ham = getAggHamiltonian(
        agg,
        aggIndices,
        franckCondonFactors;
        groundState = groundState,
        groundEnergy = true,
    )

    Ham_S =
        getAggHamSysBath(agg, aggIndices; groundState = groundState, groundEnergy = true)
    H_int = Ham.data - Ham_S.data
    b = GenericBasis([aggIndLen])
    return DenseOperator(b, b, H_int)
end

getAggHamiltonianInteraction(
    agg::Aggregate{T,C1,C2};
    groundState::Bool = false,
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType} = getAggHamiltonianInteraction(
    agg::Aggregate{T,C1,C2},
    nothing,
    nothing;
    groundState = groundState,
)

getAggHamiltonianInteraction(
    agg::Aggregate{T,C1,C2},
    aggIndices::Any;
    groundState::Bool = false,
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType} = getAggHamiltonianInteraction(
    agg::Aggregate{T,C1,C2},
    aggIndices,
    nothing;
    groundState = groundState,
)

### Sparse versions

"""
    getFranckCondonFactorsSparse(agg, aggIndices; groundState = true)
    getFranckCondonFactorsSparse(agg; groundState = true)

Sparse version of [`getFranckCondonFactors`](@ref).

"""
function getFranckCondonFactorsSparse(
    agg::Aggregate{T,C1,C2},
    aggIndices::Any;
    groundState::Bool = true,
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType}
    if aggIndices === nothing
        aggIndices = getIndices(agg; groundState = groundState)
    end
    aggIndLen = length(aggIndices)
    molLen = length(agg.molecules)
    FC = spzeros(C2, aggIndLen, aggIndLen)
    for I = 1:aggIndLen
        elind1, vibind1 = aggIndices[I]
        for J = 1:aggIndLen
            elind2, vibind2 = aggIndices[J]
            if elind1 == elind2
                if vibind1 == vibind2
                    FC[I, J] = 1.0
                end
            else
                fc = 1.0::C2
                for mi = 1:molLen
                    mol = agg.molecules[mi]
                    fc *=
                        getMolStateFC(mol, elind1[mi], vibind1[mi], elind2[mi], vibind2[mi])
                end
                if fc != 0.0
                    FC[I, J] = fc
                end
            end
        end
    end
    return FC
end

getFranckCondonFactorsSparse(
    agg::Aggregate{T,C1,C2};
    groundState::Bool = true,
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType} = getFranckCondonFactorsSparse(
    agg::Aggregate{T,C1,C2},
    nothing;
    groundState = groundState,
)

"""
    getAggHamiltonianSparse(agg, aggIndices; groundState = true)
    getAggHamiltonianSparse(agg; groundState = true)

Sparse version of [`getAggHamiltonian`](@ref).

"""
function getAggHamiltonianSparse(
    agg::Aggregate{T,C1,C2},
    aggIndices::Any,
    franckCondonFactors::Any;
    groundState::Bool = false,
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType}
    if aggIndices === nothing
        aggIndices = getIndices(agg; groundState = groundState)
    end
    aggIndLen = length(aggIndices)
    molLen = length(agg.molecules)
    if franckCondonFactors === nothing
        franckCondonFactors = getFranckCondonFactors(agg, aggIndices)
    end
    Ham = spzeros(C2, aggIndLen, aggIndLen)
    for I = 1:aggIndLen
        elind1, vibind1 = aggIndices[I]
        elOrder1 = elIndOrder(elind1)
        for J = 1:aggIndLen
            elind2, vibind2 = aggIndices[J]
            elOrder2 = elIndOrder(elind2)
            if I == J
                val = getAggStateEnergy(agg, elind1, vibind1)
                if val != 0.0
                    Ham[I, J] = val
                end
            else
                if elind1 != elind2
                    val = agg.coupling[elOrder1, elOrder2] * franckCondonFactors[I, J]
                    if val != 0.0
                        Ham[I, J] = val
                    end
                end
            end
        end
    end
    E0 = Ham[1, 1]
    for I = 1:aggIndLen
        Ham[I, I] -= E0
    end
    b = GenericBasis([aggIndLen])
    return SparseOperator(b, b, Ham)
end

getAggHamiltonianSparse(
    agg::Aggregate{T,C1,C2};
    groundState::Bool = true,
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType} = getAggHamiltonianSparse(
    agg::Aggregate{T,C1,C2},
    nothing,
    nothing;
    groundState = groundState,
)

getAggHamiltonianSparse(
    agg::Aggregate{T,C1,C2},
    aggIndices::Any;
    groundState::Bool = true,
) where {T<:Integer,C1<:ComputableType,C2<:ComputableType} = getAggHamiltonianSparse(
    agg::Aggregate{T,C1,C2},
    aggIndices,
    nothing;
    groundState = groundState,
)

"""
    setupAggregate(agg; groundState=false, groundEnergy=true, verbose=false)

Generate all basic data from the [`Aggregate`](@ref). Returns
`aggInds, vibindices, aggIndLen, basis, FCFact, FCProd, Ham, Ham_0, Ham_I`.

"""
function setupAggregate(agg; groundState = false, groundEnergy = true, verbose = false)
    if verbose
        println("aggInds")
        @time aggInds = getIndices(agg; groundState = groundState)
        println("vibindices")
        @time vibindices = getVibIndices(agg, aggInds)
        aggIndLen = length(aggInds)
        println("aggIndLen: ", aggIndLen)
        println("basis")
        @time basis = GenericBasis([aggIndLen])
        println("FCFact")
        @time FCFact = getFranckCondonFactors(agg, aggInds; groundState = groundState)
        println("FCProd")
        @time FCProd =
            getFCProd(agg, FCFact, aggInds, vibindices; groundState = groundState)
        println("Ham")
        @time Ham = getAggHamiltonian(
            agg,
            aggInds,
            FCFact;
            groundState = groundState,
            groundEnergy = groundEnergy,
        )
        println("Ham_0")
        @time Ham_0 = getAggHamSysBath(
            agg,
            aggInds;
            groundState = groundState,
            groundEnergy = groundEnergy,
        )
        println("Ham_I")
        @time Ham_I = Ham - Ham_0
    else
        aggInds = getIndices(agg; groundState = groundState)
        vibindices = getVibIndices(agg, aggInds)
        aggIndLen = length(aggInds)
        basis = GenericBasis([aggIndLen])
        FCFact = getFranckCondonFactors(agg, aggInds; groundState = groundState)
        FCProd = getFCProd(agg, FCFact, aggInds, vibindices; groundState = groundState)
        Ham = getAggHamiltonian(
            agg,
            aggInds,
            FCFact;
            groundState = groundState,
            groundEnergy = groundEnergy,
        )
        Ham_0 = getAggHamSysBath(
            agg,
            aggInds;
            groundState = groundState,
            groundEnergy = groundEnergy,
        )
        Ham_I = Ham - Ham_0
    end
    return (aggInds, vibindices, aggIndLen, basis, FCFact, FCProd, Ham, Ham_0, Ham_I)
end
