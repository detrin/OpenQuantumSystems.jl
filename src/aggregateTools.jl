
abstract type AbstractAggregateTools end

const ElIndices = Vector{Vector{T}} where T <: Integer
const VibIndices = Vector{Vector{Vector{Int64}}} where T <: Integer
# TODO: be more specific for T
const Indices = Vector{Vector{Vector{T} where T}}
const IndicesMap = Vector{Vector{T}} where T <: Integer 
const FCfactorsT = Matrix{T} where T <: AbstractFloat

"""
    vibrationalIndices(aggCore)

Get all electronic indices of the [`Aggregate`](@ref).

# Arguments
* `aggCore`: Instance of [`Aggregate`](@ref).
"""
function electronicIndices(aggCore::AggregateCore)::ElIndices
    # TODO: add typeofs
    vibInds = Array{Array{Int64,1},1}(undef, 0)
    molCount = length(aggCore.molecules)
    currentInds = fill(1, (molCount))
    push!(vibInds, copy(currentInds))
    for indPos = 1:molCount
        currentInds[indPos] += 1
        push!(vibInds, copy(currentInds))
        currentInds[indPos] -= 1
    end
    return vibInds
end

"""
    vibrationalIndices(aggCore)

Get all vibrational indices of the [`Aggregate`](@ref).

"""
function vibrationalIndices(aggCore::AggregateCore)::VibIndices
    # TODO: add typeofs
    NvibMols = getNvib(aggCore)
    molLen = length(aggCore.molecules)
    NvibIndMols = Array{Array{Array{Int64,1},1},1}(undef, 0)
    for mol_i = 1:molLen
        push!(NvibIndMols, vibrationalIndices(NvibMols[mol_i]))
    end
    molNvib = map((vibInds) -> length(vibInds), NvibIndMols)
    molInds = vibrationalIndices(molNvib)
    aggInds = Array{Array{Array{Int64,1},1},1}(undef, 0)
    for molInd in molInds
        aggInd = Array{Array{Int64,1},1}(undef, 0)
        for mol_i = 1:molLen
            push!(aggInd, NvibIndMols[mol_i][molInd[mol_i]])
        end
        push!(aggInds, aggInd)
    end
    return aggInds
end

"""
    getIndices(aggCore)

Get all indices (electronic and vibrational) of the [`Aggregate`](@ref).

# Arguments
* `aggCore`: Instance of [`Aggregate`](@ref).
"""
function getIndices(aggCore::AggregateCore)::Indices
    vibInds = vibrationalIndices(aggCore)
    vibIndsLen = length(vibInds)
    elInds = electronicIndices(aggCore)
    elIndsLen = length(elInds)
    indices = Array{Array{Array{Int64,1} where Int64,1},1}(undef, 0)
    for el_i = 1:elIndsLen
        for vib_i = 1:vibIndsLen
            push!(indices, [elInds[el_i], vibInds[vib_i]])
        end
    end
    return indices
end

"""
getIndicesMap(aggCore)

Get pointers (integers) to the indices of the [`Aggregate`](@ref) separated by 
electronic states (e.g. [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]).

# Arguments
* `agg`: Instance of [`Aggregate`](@ref).
"""
function getIndicesMap(aggCore::AggregateCore, aggIndices::Indices)::IndicesMap
    aggIndLen = length(aggIndices)
    indicesMap = Array{Array{Int64,1},1}(undef, 0)
    elLen = length(aggCore.molecules) + 1
    for el_i = 1:elLen
        push!(indicesMap, Array{Int64,1}(undef, 0))
    end

    for I = 1:aggIndLen
        elind1, vibind1 = aggIndices[I]
        elOrder1 = OpenQuantumSystems.elIndOrder(elind1)
        push!(indicesMap[elOrder1], I)
    end
    return indicesMap
end

"""
    getFranckCondonFactors(aggCore, aggIndices)
    getFranckCondonFactors(aggCore)

Get Frack-Condon factors of the [`Aggregate`](@ref) in a form of matrix.

# Arguments
* `aggCore`: Instance of [`Aggregate`](@ref).
* `aggIndices`: Aggregate indices generated by [`getIndices`](@ref).
"""
function getFranckCondonFactors(
    aggCore::AggregateCore,
    aggIndices::Indices
)::FCfactorsT
    if aggIndices === nothing
        aggIndices = getIndices(aggCore)
    end
    aggIndLen = length(aggIndices)
    molLen = length(aggCore.molecules)
    FC = zeros(Float64, (aggIndLen, aggIndLen))
    for I = 1:aggIndLen
        elind1, vibind1 = aggIndices[I]
        for J = 1:aggIndLen
            elind2, vibind2 = aggIndices[J]
            if elind1 == elind2
                if vibind1 == vibind2
                    FC[I, J] = 1.0
                end
            else
                fc = 1.0::Float64
                for mi = 1:molLen
                    mol = aggCore.molecules[mi]
                    fc *=
                        getMolStateFC(mol, elind1[mi], vibind1[mi], elind2[mi], vibind2[mi])
                end
                FC[I, J] = fc
            end
        end
    end
    return FC
end

getFranckCondonFactors(
    aggCore::AggregateCore
    )::FCfactorsT = getFranckCondonFactors(aggCore, nothing)

# TODO: resurrect sparse version
#=
"""
    getFranckCondonFactorsSparse(agg, aggIndices)
    getFranckCondonFactorsSparse(agg)

Sparse version of [`getFranckCondonFactors`](@ref).

"""
function getFranckCondonFactorsSparse(
    agg::C,
    aggIndices::Any
) where {C<:AbstractAggregateCore}
    if aggIndices === nothing
        aggIndices = getIndices(agg)
    end
    aggIndLen = length(aggIndices)
    molLen = length(agg.molecules)
    FC = spzeros(C2, aggIndLen, aggIndLen)
    for I = 1:aggIndLen
        elind1, vibind1 = aggIndices[I]
        for J = 1:aggIndLen
            elind2, vibind2 = aggIndices[J]
            if elind1 == elind2
                if vibind1 == vibind2
                    FC[I, J] = 1.0
                end
            else
                fc = 1.0::C2
                for mi = 1:molLen
                    mol = agg.molecules[mi]
                    fc *=
                        getMolStateFC(mol, elind1[mi], vibind1[mi], elind2[mi], vibind2[mi])
                end
                if fc != 0.0
                    FC[I, J] = fc
                end
            end
        end
    end
    return FC
end

getFranckCondonFactorsSparse(
    agg::C
) where {C<:AbstractAggregateCore} = getFranckCondonFactorsSparse(
    agg::C,
    nothing
)
=#

struct AggregateTools <: AbstractAggregateTools
    elIndices::ElIndices
    vibIndices::VibIndices
    indices::Indices
    indicesMap::IndicesMap
    FCfactors::FCfactorsT
    basisSystem::GenericBasis
    basisBath::GenericBasis
    basis::GenericBasis
    bSystemSize::Int64
    bBathSize::Int64
    bSize::Int64
    function AggregateTools(
        elIndices::ElIndices,
        vibIndices::VibIndices,
        indices::Indices,
        indicesMap::IndicesMap,
        FCfactors::FCfactorsT,
        basisSystem::GenericBasis,
        basisBath::GenericBasis,
        basis::GenericBasis,
        bSystemSize::Int64,
        bBathSize::Int64,
        bSize::Int64,
    )::AggregateTools
        new(
            elIndices, vibIndices, indices, indicesMap, FCfactors, 
            basisSystem, basisBath, basis, bSystemSize, bBathSize, bSize
        )
    end
end

function AggregateTools(aggCore::AggregateCore)::AggregateTools
    elIndices = electronicIndices(aggCore)
    vibIndices = vibrationalIndices(aggCore)
    indices = getIndices(aggCore)
    indicesMap = getIndicesMap(aggCore, indices)
    FCfactors = getFranckCondonFactors(aggCore, indices)
    
    bSystemSize = length(elIndices)
    bBathSize = length(vibIndices)
    bSize = length(indices)

    basisSystem = GenericBasis([bSystemSize])
    basisBath = GenericBasis([bBathSize])
    basis = GenericBasis([bSize])
    

    return AggregateTools(
        elIndices, vibIndices, indices, indicesMap, FCfactors, 
        basisSystem, basisBath, basis, bSystemSize, bBathSize, bSize
    )
end