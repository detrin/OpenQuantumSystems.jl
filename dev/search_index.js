var documenterSearchIndex = {"docs":
[{"location":"#","page":"Home","title":"Home","text":"CurrentModule=OpenQuantumSystems","category":"page"},{"location":"#OpenQuantumSystems-1","page":"Home","title":"OpenQuantumSystems","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"OpenQuantumSystems.jl may help you with simulating common open quantum systems with main focus on systems connected to quantum biology. ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Documentation is under construction. ","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: under construction)","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"You can obtain OpenQuantumSystems using Julia's Pkg REPL-mode (hitting ] as the first character of the command prompt):","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(v1.6) pkg> add OpenQuantumSystems","category":"page"},{"location":"#","page":"Home","title":"Home","text":"or with using Pkg; Pkg.add(\"OpenQuantumSystems\").","category":"page"},{"location":"documentation/#","page":"Documentation","title":"Documentation","text":"CurrentModule=OpenQuantumSystems","category":"page"},{"location":"documentation/#Aggregate-1","page":"Documentation","title":"Aggregate","text":"","category":"section"},{"location":"documentation/#","page":"Documentation","title":"Documentation","text":"Modules = [OpenQuantumSystems]\nPages   = [\"aggregate.jl\"]","category":"page"},{"location":"documentation/#OpenQuantumSystems.setupAggregate-Tuple{AggregateCore}","page":"Documentation","title":"OpenQuantumSystems.setupAggregate","text":"setupAggregate(agg; groundEnergy=true, verbose=false)\n\nGenerate all basic data from the Aggregate. Returns aggInds, vibindices, aggIndLen, basis, FCFact, FCProd, Ham, Ham_0, Ham_I.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Evolution-1","page":"Documentation","title":"Evolution","text":"","category":"section"},{"location":"documentation/#","page":"Documentation","title":"Documentation","text":"Modules = [OpenQuantumSystems]\nPages   = [\"evolution.jl\"]","category":"page"},{"location":"documentation/#OpenQuantumSystems.evolutionApproximate!-Union{Tuple{C}, Tuple{Array{Matrix{C}, 1}, Operator, Array, Operator}} where C<:Union{AbstractFloat, Complex}","page":"Documentation","title":"OpenQuantumSystems.evolutionApproximate!","text":"evolutionApproximate!(op_array, op0, tspan, Hamiltonian)\n\nCalculate approximate time evolution of the op0 inplace based on U(t) that is  calculated for t_0 and t_textstep. See evolutionOperator. This method returns Vector of Arrays.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.evolutionApproximate!-Union{Tuple{C}, Tuple{Array{Vector{C}, 1}, Ket, Array, Operator}} where C<:Union{AbstractFloat, Complex}","page":"Documentation","title":"OpenQuantumSystems.evolutionApproximate!","text":"evolutionApproximate!(ket_array, ket0, tspan, Hamiltonian)\n\nCalculate approximate time evolution of the ket0 inplace based on U(t) that is  calculated for t_0 and t_textstep. See evolutionOperator. Argument ket_array is Vector of Arrays.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.evolutionApproximate-Tuple{Ket, Array, Operator}","page":"Documentation","title":"OpenQuantumSystems.evolutionApproximate","text":"evolutionApproximate(ket0, tspan, Hamiltonian)\n\nCalculate approximate time evolution of the ket0 based on U(t) that is  calculated for t_0 and t_textstep. See evolutionOperator. This method returns Vector of Ket states.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.evolutionApproximate-Tuple{Operator, Array, Operator}","page":"Documentation","title":"OpenQuantumSystems.evolutionApproximate","text":"evolutionApproximate(op0, tspan, Hamiltonian)\n\nCalculate approximate time evolution of the op0 based on U(t) that is  calculated for t_0 and t_textstep. See evolutionOperator. This method returns Vector of Operators.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.evolutionExact!-Union{Tuple{C}, Tuple{Array{Matrix{C}, 1}, Operator, Array, Operator}} where C<:Union{AbstractFloat, Complex}","page":"Documentation","title":"OpenQuantumSystems.evolutionExact!","text":"evolutionExact!(op_array, op0, tspan, Hamiltonian; \n\tdiagonalize = true, approximate = false)\n\nCalculate exact time evolution of the op0 state inplace see evolutionOperatorIterator.  The diagonalize argument decompose Hamiltonian into lambda_i S S^-1 and calculate the exponential using eigenvalue decomposition. The approximate option asusmes that tspan is made of  equidistant points, therefore U(t) has to be calculated for t_0 and t_textstep.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.evolutionExact!-Union{Tuple{C}, Tuple{Array{Vector{C}, 1}, Ket, Array, Operator}} where C<:Union{AbstractFloat, Complex}","page":"Documentation","title":"OpenQuantumSystems.evolutionExact!","text":"evolutionExact!(ket_array, ket0, tspan, Hamiltonian; \n\tdiagonalize = true, approximate = false)\n\nCalculate exact time evolution of the ket0 state inplace see evolutionOperatorIterator.  The diagonalize argument decompose Hamiltonian into lambda_i S S^-1 and calculate the exponential using eigenvalue decomposition. The approximate option asusmes that tspan is made of  equidistant points, therefore U(t) has to be calculated for t_0 and t_textstep.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.evolutionExact-Tuple{Ket, Array, Operator}","page":"Documentation","title":"OpenQuantumSystems.evolutionExact","text":"evolutionExact(ket0, tspan, Hamiltonian; diagonalize = true, approximate = false)\n\nCalculate exact time evolution of the ket0 state see evolutionOperatorIterator.  The diagonalize argument decompose Hamiltonian into lambda_i S S^-1 and calculate the exponential using eigenvalue decomposition. The approximate option asusmes that tspan is made of  equidistant points, therefore U(t) has to be calculated for t_0 and t_textstep.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.evolutionExact-Tuple{Operator, Array, Operator}","page":"Documentation","title":"OpenQuantumSystems.evolutionExact","text":"evolutionExact(op0, tspan, Hamiltonian; diagonalize = true, approximate = false)\n\nCalculate exact time evolution of the op0 state see evolutionOperatorIterator.  The diagonalize argument decompose Hamiltonian into lambda_i S S^-1 and calculate the exponential using eigenvalue decomposition. The approximate option asusmes that tspan is made of  equidistant points, therefore U(t) has to be calculated for t_0 and t_textstep.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.evolutionOperator-Tuple{Operator, AbstractFloat}","page":"Documentation","title":"OpenQuantumSystems.evolutionOperator","text":"evolutionOperator(Hamiltonian, t)\n\nGet evolution operator as Operator using the definition\n\nU(t) = e^-i H t  hbar quad hbar = 1.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.evolutionOperatorA-Tuple{Array, Array, Array, AbstractFloat}","page":"Documentation","title":"OpenQuantumSystems.evolutionOperatorA","text":"evolutionOperatorA(H_lambda, S, Sinv, t)\n\nGet evolution operator as Array using the definition\n\nU(t) = S e^-i H_lambda t  hbar S^-1\n\nwhere hbar = 1, H_lambdaii = lambda_i are eigenvalues of H, so H has to be non-singular, otherwise H_lambdaij = 0 i neq j.  S is obtained from eigendecomposition of H, for example\n\nH_lambda, S = eigen(Hamiltonian.data)\nSinv = inv(S)\nH_lambda = diagm(H_lambda)\n\nand arguments have to be Arrays.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.evolutionOperatorArray-Tuple{Operator, Array}","page":"Documentation","title":"OpenQuantumSystems.evolutionOperatorArray","text":"evolutionOperatorArray(Hamiltonian, tspan)\n\nGet evolution operators as Vector or Operators using the definition\n\nU(t) = e^-i H t  hbar quad hbar = 1.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.evolutionOperatorIterator","page":"Documentation","title":"OpenQuantumSystems.evolutionOperatorIterator","text":"evolutionOperatorIterator(Hamiltonian, tspan; diagonalize = true, approximate = false)\n\nResumable function that returns evolution operator as Operator type at the time t from tspan. See evolutionOperator. The diagonalize argument decompose Hamiltonian into lambda_i S S^-1 and calculate the exponential using eigenvalue decomposition. The approximate option asusmes that tspan is made of  equidistant points, therefore U(t) has to be calculated for t_0 and t_textstep.\n\n\n\n\n\n","category":"function"},{"location":"documentation/#OpenQuantumSystems.evolutionSuperOperator-Tuple{Operator, AbstractFloat}","page":"Documentation","title":"OpenQuantumSystems.evolutionSuperOperator","text":"evolutionSuperOperator(Hamiltonian, t)\n\nGet evolution operator as SuperOperator using the definition\n\nmathcalU(t) cdot = U(t) cdot U^dagger(t) = e^-i H t  hbar cdot e^i H t  hbar quad hbar = 1.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.evolutionSuperOperatorArray-Tuple{Operator, Array}","page":"Documentation","title":"OpenQuantumSystems.evolutionSuperOperatorArray","text":"evolutionOperatorArray(Hamiltonian, tspan)\n\nGet evolution superoperators as Vector or SuperOperators using the definition\n\nmathcalU(t) cdot = U(t) cdot U^dagger(t) = e^-i H t  hbar cdot e^i H t  hbar quad hbar = 1.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.evolutionSuperOperatorIterator","page":"Documentation","title":"OpenQuantumSystems.evolutionSuperOperatorIterator","text":"evolutionSuperOperatorIterator(Hamiltonian, tspan; \n\tdiagonalize = true, approximate = false)\n\nResumable function that returns evolution operator as Operator type at the time t from tspan. See evolutionSuperOperator. The diagonalize argument decompose Hamiltonian into lambda_i S S^-1 and calculate the exponential using eigenvalue decomposition. The approximate option asusmes that tspan is made of  equidistant points, therefore U(t) has to be calculated for t_0 and t_textstep.\n\n\n\n\n\n","category":"function"},{"location":"documentation/#OpenQuantumSystems.evolution_approximate-Union{Tuple{U}, Tuple{T}, Tuple{B}, Tuple{T, Array, U}} where {B<:Basis, T<:(Operator{B, B}), U<:(Operator{B, B})}","page":"Documentation","title":"OpenQuantumSystems.evolution_approximate","text":"evolution_exact(rho0, tspan, Hamiltonian; diagonalize = false)\n\nCalculate approximate time evolution of the rho0 based on U(t) that is  calculated for t_0 and t_textstep. The diagonalize argument decompose Hamiltonian into lambda_i S S^-1 and calculate the exponential using eigenvalue decomposition. See evolutionOperator. This method returns tspan and Vector of Operators.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.evolution_exact-Union{Tuple{U}, Tuple{T}, Tuple{B}, Tuple{T, Array, U}} where {B<:Basis, T<:(Operator{B, B}), U<:(Operator{B, B})}","page":"Documentation","title":"OpenQuantumSystems.evolution_exact","text":"evolution_exact(rho0, tspan, Hamiltonian; diagonalize = false)\n\nCalculate exact time evolution of the rho0 inplace based on U(t).  The diagonalize argument decompose Hamiltonian into lambda_i S S^-1 and calculate the exponential using eigenvalue decomposition. See evolutionOperator. This method returns tspan and Vector of Operators.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Initial-State-1","page":"Documentation","title":"Initial State","text":"","category":"section"},{"location":"documentation/#","page":"Documentation","title":"Documentation","text":"Modules = [OpenQuantumSystems]\nPages   = [\"initial_state.jl\"]","category":"page"},{"location":"documentation/#OpenQuantumSystems.thermal_state-Tuple{Any, Any, AggregateCore, AggregateTools, AggregateOperators}","page":"Documentation","title":"OpenQuantumSystems.thermal_state","text":"thermal_state(T, mu_array, Ham, aggIndices; \n\tboltzmann_const = 0.69503476, diagonalize = false, diagonal = false)\n\nGet initial state as thermal state excited with ultra-fast laser pulse. In this version we suppose that after the thermal state is excited with laser pulse, the whole population  of ground state is distributed over electric states in mu_array. We assume  Condon approximation.\n\nrho_textthermal = exp( -fracihbar H ) quad hbar = 1`.\n\nArguments\n\nT: Temperature of the initial thermal state.\nmu_array: Vector of electric states in local basis, see electronicIndices. The first       index is for ground state of the aggregate the rest are first excited states in local basis.\nHam: Arbitrary operator specifying the Hamiltonian.\naggIndices: Aggregate indices, see getIndices.\nboltzmann_const: Boltzmann const in mathrmcm^-1.\ndiagonalize: Decompose Hamiltonian into lambda_i S S^-1       and calculate the exponential using eigenvalue decomposition.\ndiagonal: Return only the diagonal part of the excited density matrix.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.thermal_state_composite-Tuple{Any, Any, AggregateCore, AggregateTools, AggregateOperators}","page":"Documentation","title":"OpenQuantumSystems.thermal_state_composite","text":"thermal_state_composite(T, mu_weighted, Ham, aggIndices; \n\tboltzmann_const::Float64 = 0.69503476, diagonalize::Bool=false, diagonal=false)\n\nFunctionality of this method is similar to thermal_state, but the final  state is constructed from partial thermal_states with weight specified in mu_weighted. For example \n\njulia thermal_state_composite(T, [0.0, 0.8, 0.2], ...) = 0.8 * thermal_state(T, [1, 2, 1], ...) + 0.2 * thermal_state(T, [1, 1, 2], ...)`\n\nrho_textthermal = exp( -fracihbar H ) quad hbar = 1.\n\nArguments\n\nT: Temperature of the initial thermal state.\nmu_weighted: Vector of weights of electric states in local basis, see electronicIndices.\nHam: Arbitrary operator specifying the Hamiltonian.\naggIndices: Aggregate indices, see getIndices.\nboltzmann_const: Boltzmann const in mathrmcm^-1.\ndiagonalize: Decompose Hamiltonian into lambda_i S S^-1       and calculate the exponential using eigenvalue decomposition.\ndiagonal: Return only the diagonal part of the excited density matrix.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Interaction-Picture-1","page":"Documentation","title":"Interaction Picture","text":"","category":"section"},{"location":"documentation/#","page":"Documentation","title":"Documentation","text":"Modules = [OpenQuantumSystems]\nPages   = [\"interaction_picture.jl\"]","category":"page"},{"location":"documentation/#Liouville-von-Neumann-Equation-1","page":"Documentation","title":"Liouville-von Neumann Equation","text":"","category":"section"},{"location":"documentation/#","page":"Documentation","title":"Documentation","text":"Modules = [OpenQuantumSystems]\nPages   = [\"liouville.jl\"]","category":"page"},{"location":"documentation/#OpenQuantumSystems.LvN_sI-Union{Tuple{T}, Tuple{B}, Tuple{T, Array, Aggregate}} where {B<:Basis, T<:(Operator{B, B})}","page":"Documentation","title":"OpenQuantumSystems.LvN_sI","text":"liouvilleVonNeumann(rho0, tspan, H; \n\treltol=1.0e-12, abstol=1.0e-12, fout=nothing, alg=OrdinaryDiffEq.Tsit5())\n\nIntegrate Liouville-von Neumann equation to evolve states or compute propagators\n\nfracdd t rho(t) = - fracihbar  hat H rho(t)  quad hbar = 1.\n\nArguments\n\nrho0: Initial state vector (can be a bra or a ket) or initial propagator.\ntspan: Vector specifying the points of time for which output should be displayed.\nH: Arbitrary operator specifying the Hamiltonian.\nreltol: Relative tolerance for OrdinaryDiffEq solver and its inner states.\nabstol: Absolute tolerance for OrdinaryDiffEq solver and its inner states.\nfout=nothing: If given, this function fout(t, rho) is called every time       an output should be displayed. ATTENTION: The state rho is neither       normalized nor permanent! It is still in use by the ode solver and       therefore must not be changed.\nalg: Algorithm with which OrdinaryDiffEq will solve LvN equation.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Quantum-Master-Equation-1","page":"Documentation","title":"Quantum Master Equation","text":"","category":"section"},{"location":"documentation/#","page":"Documentation","title":"Documentation","text":"Modules = [OpenQuantumSystems]\nPages   = [\"master.jl\"]","category":"page"},{"location":"documentation/#Memory-Kernel-1","page":"Documentation","title":"Memory Kernel","text":"","category":"section"},{"location":"documentation/#","page":"Documentation","title":"Documentation","text":"Modules = [OpenQuantumSystems]\nPages   = [\"memory_kernel.jl\"]","category":"page"},{"location":"documentation/#OpenQuantumSystems.MemoryKernel_1_traced-Tuple{Array, Array, Array, AggregateCore, AggregateOperators, AggregateTools}","page":"Documentation","title":"OpenQuantumSystems.MemoryKernel_1_traced","text":"MemoryKernel_1_traced(H_II_t, H_II_tau, W_bath, agg, FCProd, aggIndices, indicesMap)\n\nCalculate the first part of Memory Kernel with the definition\n\nmathcalM_1(t tau) = operatornametr_B  hatH_I^(I)(t) hatH_I^(I)(tau) W_textbath .\n\nArguments\n\nH_II_t: Interaction Hamiltonian in interaction picutre at the time t, hatH_I^(I)(t).\nH_II_tau: Interaction Hamiltonian in interaction picutre at the time tau, hatH_I^(I)(tau).\nW_bath: Density matrix representing bath part of the density matrix, see get_rho_bath.\nagg: Aggregate of molecules, see Aggregate.\naggIndices: Aggregate indices, see getIndices.\nindicesMap: Aggregate vibrational indices, see getVibIndices.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.MemoryKernel_2_traced-Tuple{Array, Array, Array, AggregateCore, AggregateOperators, AggregateTools}","page":"Documentation","title":"OpenQuantumSystems.MemoryKernel_2_traced","text":"MemoryKernel_2_traced(H_II_t, H_II_tau, W_bath, agg, FCProd, aggIndices, indicesMap)\n\nCalculate the second part of Memory Kernel with the definition\n\nmathcalM_1(t tau) = operatornametr_B  hatH_I^(I)(t) W_textbath hatH_I^(I)(tau) .\n\nArguments\n\nH_II_t: Interaction Hamiltonian in interaction picutre at the time t, hatH_I^(I)(t).\nH_II_tau: Interaction Hamiltonian in interaction picutre at the time tau, hatH_I^(I)(tau).\nW_bath: Density matrix representing bath part of the density matrix, see get_rho_bath.\nagg: Aggregate of molecules, see Aggregate.\naggIndices: Aggregate indices, see getIndices.\nindicesMap: Aggregate vibrational indices, see getVibIndices.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.MemoryKernel_3_traced-Tuple{Array, Array, Array, AggregateCore, AggregateOperators, AggregateTools}","page":"Documentation","title":"OpenQuantumSystems.MemoryKernel_3_traced","text":"MemoryKernel_3_traced(H_II_t, H_II_tau, W_bath, agg, FCProd, aggIndices, indicesMap)\n\nCalculate the third part of Memory Kernel with the definition\n\nmathcalM_1(t tau) = operatornametr_B  hatH_I^(I)(tau) W_textbath hatH_I^(I)(t) .\n\nArguments\n\nH_II_t: Interaction Hamiltonian in interaction picutre at the time t, hatH_I^(I)(t).\nH_II_tau: Interaction Hamiltonian in interaction picutre at the time tau, hatH_I^(I)(tau).\nW_bath: Density matrix representing bath part of the density matrix, see get_rho_bath.\nagg: Aggregate of molecules, see Aggregate.\naggIndices: Aggregate indices, see getIndices.\nindicesMap: Aggregate vibrational indices, see getVibIndices.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.MemoryKernel_4_traced-Tuple{Array, Array, Array, AggregateCore, AggregateOperators, AggregateTools}","page":"Documentation","title":"OpenQuantumSystems.MemoryKernel_4_traced","text":"MemoryKernel_4_traced(H_II_t, H_II_tau, W_bath, agg, FCProd, aggIndices, indicesMap)\n\nCalculate the fourth part of Memory Kernel with the definition\n\nmathcalM_1(t tau) = operatornametr_B  W_textbath hatH_I^(I)(t) hatH_I^(I)(tau) .\n\nArguments\n\nH_II_t: Interaction Hamiltonian in interaction picutre at the time t, hatH_I^(I)(t).\nH_II_tau: Interaction Hamiltonian in interaction picutre at the time tau, hatH_I^(I)(tau).\nW_bath: Density matrix representing bath part of the density matrix, see get_rho_bath.\nagg: Aggregate of molecules, see Aggregate.\naggIndices: Aggregate indices, see getIndices.\nindicesMap: Aggregate vibrational indices, see getVibIndices.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.MemoryKernel_traced-Tuple{Array, Array, Array, AggregateCore, AggregateOperators, AggregateTools}","page":"Documentation","title":"OpenQuantumSystems.MemoryKernel_traced","text":"MemoryKernel_traced(H_II_t, H_II_tau, W_bath, agg, FCProd, aggIndices, indicesMap)\n\nCalculate Memory Kernel with the definition\n\nmathcalM(t tau) = operatornametr_B   hatH_I^(I)(t)  hatH_I^(I)(tau) W_textbath .\n\nArguments\n\nH_II_t: Interaction Hamiltonian in interaction picutre at the time t, hatH_I^(I)(t).\nH_II_tau: Interaction Hamiltonian in interaction picutre at the time tau, hatH_I^(I)(tau).\nW_bath: Density matrix representing bath part of the density matrix, see get_rho_bath.\nagg: Aggregate of molecules, see Aggregate.\naggIndices: Aggregate indices, see getIndices.\nindicesMap: Aggregate vibrational indices, see getVibIndices.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Metrics-1","page":"Documentation","title":"Metrics","text":"","category":"section"},{"location":"documentation/#","page":"Documentation","title":"Documentation","text":"Modules = [OpenQuantumSystems]\nPages   = [\"metrics.jl\"]","category":"page"},{"location":"documentation/#QuantumOpticsBase.tracedistance-Union{Tuple{T}, Tuple{B}, Tuple{SuperOperator{B, B, T}, SuperOperator{B, B, T}}} where {B<:Tuple{Basis, Basis}, T}","page":"Documentation","title":"QuantumOpticsBase.tracedistance","text":"tracedistance(rho, sigma)\n\nTrace distance between rho and sigma. It is defined as\n\nT(ρσ) = frac12 operatornametrsqrt(ρ - σ)^ (ρ - σ)\n\nIt calls tracenorm which in turn either uses tracenorm_h or tracenorm_nh depending if ρ-σ is hermitian or not.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#QuantumOpticsBase.tracedistance_h-Union{Tuple{T}, Tuple{B}, Tuple{SuperOperator{B, B, T}, SuperOperator{B, B, T}}} where {B<:Tuple{Basis, Basis}, T}","page":"Documentation","title":"QuantumOpticsBase.tracedistance_h","text":"tracedistance_h(rho, sigma)\n\nTrace distance between rho and sigma. It uses the identity\n\nT(ρσ) = frac12 operatornametrsqrt(ρ - σ)^ (ρ - σ) = frac12 sum_i λ_i\n\nwhere λ_i are the eigenvalues of rho - sigma.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#QuantumOpticsBase.tracedistance_nh-Union{Tuple{T}, Tuple{B2}, Tuple{B1}, Tuple{SuperOperator{B1, B2, T}, SuperOperator{B1, B2, T}}} where {B1<:Tuple{Basis, Basis}, B2<:Tuple{Basis, Basis}, T}","page":"Documentation","title":"QuantumOpticsBase.tracedistance_nh","text":"tracedistance_nh(rho, sigma)\n\nTrace distance between rho and sigma. Note that in this case rho and sigma don't have to be represented by square matrices (i.e. they can have different left-hand and right-hand bases). It uses the identity\n\n    T(ρσ) = frac12 operatornametrsqrt(ρ - σ)^ (ρ - σ)\n         = frac12 sum_i σ_i\n\nwhere σ_i are the singular values of rho - sigma.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#QuantumOpticsBase.tracenorm-Tuple{DenseSuperOpType}","page":"Documentation","title":"QuantumOpticsBase.tracenorm","text":"tracenorm(rho)\n\nTrace norm of rho. It is defined as\n\nT(ρ) = operatornametrsqrtρ^ ρ\n\nDepending if rho is hermitian either tracenorm_h or tracenorm_nh is called.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#QuantumOpticsBase.tracenorm_h-Union{Tuple{SuperOperator{B, B, T}}, Tuple{T}, Tuple{B}} where {B<:Tuple{Basis, Basis}, T}","page":"Documentation","title":"QuantumOpticsBase.tracenorm_h","text":"tracenorm_h(rho)\n\nTrace norm of rho. It uses the identity\n\nT(ρ) = operatornametrsqrtρ^ ρ = sum_i λ_i\n\nwhere λ_i are the eigenvalues of rho.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#QuantumOpticsBase.tracenorm_nh-Union{Tuple{SuperOperator{B, B, T}}, Tuple{T}, Tuple{B}} where {B<:Tuple{Basis, Basis}, T}","page":"Documentation","title":"QuantumOpticsBase.tracenorm_nh","text":"tracenorm_nh(rho)\n\nTrace norm of rho. Note that in this case rho doesn't have to be represented by a square matrix (i.e. it can have different left-hand and right-hand bases). It uses the identity\n\n    T(ρ) = operatornametrsqrtρ^ ρ = sum_i σ_i\n\nwhere σ_i are the singular values of rho.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Molecules-1","page":"Documentation","title":"Molecules","text":"","category":"section"},{"location":"documentation/#","page":"Documentation","title":"Documentation","text":"Modules = [OpenQuantumSystems]\nPages   = [\"molecules.jl\"]","category":"page"},{"location":"documentation/#OpenQuantumSystems.Mode","page":"Documentation","title":"OpenQuantumSystems.Mode","text":"Mode{T}(omega, shift)\n\nStuct which purpose is to model vibrational LHO mode in Molecule.\n\nV(q) = hbar omega (q - q_0)^2 quad hbar = 1\n\nArguments\n\nomega: The frequency of LHO (omega).\nshift: The shift of the coordinate of LHO (q_0).\n\n\n\n\n\n","category":"type"},{"location":"documentation/#OpenQuantumSystems.Molecule","page":"Documentation","title":"OpenQuantumSystems.Molecule","text":"Molecule{T,C1,C2}(modes, Nvib, E)\n\nStuct which purpose is to model a molecule in Aggregate.\n\nArguments\n\nmodes: Vector of modes (Mode).\nNvib: Maximum number of vibrational states for all modes.\nE: Energy of ground and excited state of molecule (HOMO, LUMO).\n\n\n\n\n\n","category":"type"},{"location":"documentation/#OpenQuantumSystems.electronicIndices-Tuple{T} where T<:Integer","page":"Documentation","title":"OpenQuantumSystems.electronicIndices","text":"electronicIndices(molCount)\n\nGet the electric indices for all states on Aggregate.\n\nArguments\n\nmolCount: Number of molecules in Aggregate.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.franckCondonFactors-Union{Tuple{U}, Tuple{T}, Tuple{T, U}} where {T<:Integer, U<:Union{AbstractFloat, Complex}}","page":"Documentation","title":"OpenQuantumSystems.franckCondonFactors","text":"franckCondonFactors(size, shift)\n\nGet Franck-Condon factors for LHO mode calculated using ShiftOperator.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.getMolFrequencies-Union{Tuple{Molecule{T, C1, C2}}, Tuple{C2}, Tuple{C1}, Tuple{T}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}}","page":"Documentation","title":"OpenQuantumSystems.getMolFrequencies","text":"getMolFrequencies(mol)\n\nGet shifts of every mode on the Molecule state.\n\nArguments\n\nmol: Instance of Molecule.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.getMolShifts-Union{Tuple{Molecule{T, C1, C2}}, Tuple{C2}, Tuple{C1}, Tuple{T}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}}","page":"Documentation","title":"OpenQuantumSystems.getMolShifts","text":"getMolShifts(mol)\n\nGet shifts of every mode on the Molecule state.\n\nArguments\n\nmol: Instance of Molecule.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.getMolStateEnergy-Union{Tuple{U}, Tuple{C2}, Tuple{C1}, Tuple{T}, Tuple{Molecule{T, C1, C2}, U, Vector{U}}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}, U<:Integer}","page":"Documentation","title":"OpenQuantumSystems.getMolStateEnergy","text":"getMolStateEnergy(mol, molElState, molVibState)\n\nGet the energy of the Molecule state.\n\nArguments\n\nmol: Instance of Molecule.\nmolElState: Electric state of the molecule in local basis (i.e. 1 or 2, where 1 is ground state).\nmolVibState: Vibrational state of the molecule (e.g. [1, 5, 2, 2]).\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.getMolStateFC-Union{Tuple{U}, Tuple{C2}, Tuple{C1}, Tuple{T}, Tuple{Molecule{T, C1, C2}, U, Vector{U}, U, Vector{U}}} where {T<:Integer, C1<:Union{AbstractFloat, Complex}, C2<:Union{AbstractFloat, Complex}, U<:Integer}","page":"Documentation","title":"OpenQuantumSystems.getMolStateFC","text":"getMolStateFC(mol, molElState1, molVibState1, molElState2, molVibState2)\n\nGet the energy of the Molecule state.\n\nArguments\n\nmol: Instance of Molecule.\nmolElState1, molElState2: Electric state of the molecule in local basis (i.e. 1 or 2, where 1 is ground state).\nmolVibState1, molVibState2: Vibrational state of the molecule (e.g. [1, 5, 2, 2]).\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.vibrationalIndices-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Integer","page":"Documentation","title":"OpenQuantumSystems.vibrationalIndices","text":"vibrationalIndices(maxInds)\n\nGet the vibrational indices for all states on Molecule.\n\nArguments\n\nmaxInds: Vector of maximum number of vibrational states.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Dense-Operators-1","page":"Documentation","title":"Dense Operators","text":"","category":"section"},{"location":"documentation/#","page":"Documentation","title":"Documentation","text":"Modules = [OpenQuantumSystems]\nPages   = [\"operators_dense.jl\"]","category":"page"},{"location":"documentation/#OpenQuantumSystems.AnnihilationOperator","page":"Documentation","title":"OpenQuantumSystems.AnnihilationOperator","text":"AnnihilationOperator{BL,BR}(basis_l, basis_r)\n\nDense annihilation operator as a mutable struct.\n\n\n\n\n\n","category":"type"},{"location":"documentation/#OpenQuantumSystems.CreationOperator","page":"Documentation","title":"OpenQuantumSystems.CreationOperator","text":"CreationOperator{BL,BR}(basis_l, basis_r)\n\nDense creation operator as a mutable struct.\n\n\n\n\n\n","category":"type"},{"location":"documentation/#OpenQuantumSystems.MomentumOperator","page":"Documentation","title":"OpenQuantumSystems.MomentumOperator","text":"MomentumOperator{BL,BR}(basisl, basisr)\n\nDense momentum operator as a mutable struct without mass and frequency.\n\n\n\n\n\n","category":"type"},{"location":"documentation/#OpenQuantumSystems.PositionOperator","page":"Documentation","title":"OpenQuantumSystems.PositionOperator","text":"PositionOperator{BL,BR}(basis_l, basis_r)\n\nDense position operator as a mutable struct without mass and frequency.\n\n\n\n\n\n","category":"type"},{"location":"documentation/#OpenQuantumSystems.ShiftOperator","page":"Documentation","title":"OpenQuantumSystems.ShiftOperator","text":"ShiftOperator{BL,BR}(basis_l, basis_r, shift)\n\nDense shift operator as a mutable struct using the definition\n\nD(alpha) = exp(alpha a^dagger - alpha^* a).\n\nArguments\n\nbasis_l: Bra basis.\nbasis_r: Ket basis.\nshift: Shift or alpha parameter, can be complex number.\n\n\n\n\n\n","category":"type"},{"location":"documentation/#OpenQuantumSystems.OneDenseOperator-Union{Tuple{BR}, Tuple{BL}, Tuple{BL, BR}} where {BL<:Basis, BR<:Basis}","page":"Documentation","title":"OpenQuantumSystems.OneDenseOperator","text":"OneDenseOperator(basis_l, basis_r)\n\nDenseOperator with ones on the diagonal.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Schrödinger-Equation-1","page":"Documentation","title":"Schrödinger Equation","text":"","category":"section"},{"location":"documentation/#","page":"Documentation","title":"Documentation","text":"Modules = [OpenQuantumSystems]\nPages   = [\"schroedinger.jl\"]","category":"page"},{"location":"documentation/#OpenQuantumSystems.schroedinger-Union{Tuple{T}, Tuple{B}, Tuple{T, Array, AbstractOperator{B, B}}} where {B<:Basis, T<:Union{AbstractOperator{B, B}, StateVector{B}}}","page":"Documentation","title":"OpenQuantumSystems.schroedinger","text":"schroedinger(psi0, tspan, H; \n\treltol=1.0e-12, abstol=1.0e-12, fout=nothing, alg=OrdinaryDiffEq.Tsit5())\n\nIntegrate Schroedinger equation to evolve states or compute propagators\n\nfracdd tvertpsi(t)rangle = - fracihbar hat Hvertpsi(t)rangle quad hbar = 1.\n\nArguments\n\npsi0: Initial state vector (can be a bra or a ket) or initial propagator.\ntspan: Vector specifying the points of time for which output should be displayed.\nH: Arbitrary operator specifying the Hamiltonian.\nreltol: Relative tolerance for OrdinaryDiffEq solver and its inner states.\nabstol: Absolute tolerance for OrdinaryDiffEq solver and its inner states.\nfout=nothing: If given, this function fout(t, psi) is called every time       an output should be displayed. ATTENTION: The state psi is neither       normalized nor permanent! It is still in use by the ode solver and       therefore must not be changed.\nalg: Algorithm with which OrdinaryDiffEq will solve Schroedinger equation.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.schroedinger_dynamic-Union{Tuple{T}, Tuple{T, Array, Function}} where T<:Union{AbstractOperator, StateVector}","page":"Documentation","title":"OpenQuantumSystems.schroedinger_dynamic","text":"schroedinger_dynamic(psi0, tspan, f; \n\treltol=1.0e-12, abstol=1.0e-12, fout=nothing, alg=OrdinaryDiffEq.Tsit5())\n\nIntegrate time-dependent Schroedinger equation to evolve states or compute propagators\n\nfracdd tvertpsi(t)rangle = - fracihbar hat H(t)vertrho(t)rangle quad hbar = 1.\n\nArguments\n\npsi0: Initial state vector (can be a bra or a ket) or initial propagator.\ntspan: Vector specifying the points of time for which output should be displayed.\nf: Function f(t, psi) -> H returning the time and or state dependent Hamiltonian.\nreltol: Relative tolerance for OrdinaryDiffEq solver and its inner states.\nabstol: Absolute tolerance for OrdinaryDiffEq solver and its inner states.\nfout=nothing: If given, this function fout(t, psi) is called every time       an output should be displayed. ATTENTION: The state psi is neither       normalized nor permanent! It is still in use by the ode solver and       therefore must not be changed.\nalg: Algorithm with which OrdinaryDiffEq will solve Schroedinger equation.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Superoperators-1","page":"Documentation","title":"Superoperators","text":"","category":"section"},{"location":"documentation/#","page":"Documentation","title":"Documentation","text":"Modules = [OpenQuantumSystems]\nPages   = [\"superoperators.jl\"]","category":"page"},{"location":"documentation/#OpenQuantumSystems.Commutator-Tuple{Operator}","page":"Documentation","title":"OpenQuantumSystems.Commutator","text":"Commutator(A)\n\nCreate commutator in a form of superoperator from a given operator.\n\ntextCommutator(A) cdot = A cdot\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Time-evolution-Base-1","page":"Documentation","title":"Time-evolution Base","text":"","category":"section"},{"location":"documentation/#","page":"Documentation","title":"Documentation","text":"Modules = [OpenQuantumSystems]\nPages   = [\"timeevolution_base.jl\"]","category":"page"},{"location":"documentation/#OpenQuantumSystems.integrate-Union{Tuple{X}, Tuple{T}, Tuple{Any, Function, X, T, T, Function}} where {T, X}","page":"Documentation","title":"OpenQuantumSystems.integrate","text":"integrate(tspan, df::Function, x0::Vector{ComplexF64},\n        state::T, dstate::T, fout::Function; kwargs...)\n\nIntegrate using OrdinaryDiffEq\n\n\n\n\n\n","category":"method"},{"location":"documentation/#Trace-1","page":"Documentation","title":"Trace","text":"","category":"section"},{"location":"documentation/#","page":"Documentation","title":"Documentation","text":"Modules = [OpenQuantumSystems]\nPages   = [\"trace.jl\"]","category":"page"},{"location":"documentation/#OpenQuantumSystems.ad-Tuple{Array, Array, AggregateCore, AggregateTools}","page":"Documentation","title":"OpenQuantumSystems.ad","text":"ad(rho, rho_bath, agg, FCProd, aggIndices, vibindices)\n\nThis is the inverse operation to the trace over bath trace_bath and get_rho_bath  defined as follows\n\nrho = operatornameadrho_texttr rho_textbath \n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.correlation_function-Tuple{Any, Any, Any, Any, AggregateCore, AggregateOperators, AggregateTools}","page":"Documentation","title":"OpenQuantumSystems.correlation_function","text":"correlation_function(t, rho0_bath, Ham_0, Ham_I, agg, FCProd, aggInds, vibindices)\n\nGet time dependent correlation function for a specified time t using following definition\n\nC(t) = operatornametr_B  hatH_I^(I)(t) hatH_I rho_textbath(0) \n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.get_rho_bath-Tuple{Array, AggregateCore, AggregateOperators, AggregateTools}","page":"Documentation","title":"OpenQuantumSystems.get_rho_bath","text":"get_rho_bath(rho, agg, FCProd, aggIndices, vibindices; justCopy=false)\n\nThis method will return the bath part of rho knowing the result of trace_bath defined as follows\n\nrho_textbath = operatornametr_S rho\n\nrho_textbath ab = rho_ab  langle a vert operatornametr_B  rho vert b rangle\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.trace_bath-Union{Tuple{N}, Tuple{Array, N, N, AggregateTools}} where N<:Integer","page":"Documentation","title":"OpenQuantumSystems.trace_bath","text":"trace_bath(rho, a, b, agg, FCProd, aggIndices, vibindices)\n\nTrace out bath degrees of freedom from rho without the product of Franck-Condon factors. The trace will be done only on the Hilber space for electric bra part a and ket part b. Input density matrix rho is for the whole Hilber space. This method returns number.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.trace_bath_part-Union{Tuple{N}, Tuple{Array, N, N, AggregateTools}} where N<:Integer","page":"Documentation","title":"OpenQuantumSystems.trace_bath_part","text":"trace_bath_part(rho, a, b, agg, FCProd, aggIndices, vibindices)\n\nTrace out bath degrees of freedom from rho without the product of Franck-Condon factors. The trace will be done only on the Hilber space for electric bra part a and ket part b. Input density matrix rho is only for the subspace. This method returns number.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.trace_bath_slow-Tuple{Array, AggregateCore, AggregateTools}","page":"Documentation","title":"OpenQuantumSystems.trace_bath_slow","text":"trace_bath_slow(rho, agg, FCFact, aggIndices, vibindices)\n\nTrace out bath degrees of freedom from rho without the product of Franck-Condon factors.\n\n\n\n\n\n","category":"method"},{"location":"documentation/#OpenQuantumSystems.trace_bath_ground_excited-Tuple{Array, AggregateCore, AggregateTools}","page":"Documentation","title":"OpenQuantumSystems.trace_bath_ground_excited","text":"trace_bath(rho, agg, FCProd, aggIndices, vibindices)\n\nTrace out bath degrees of freedom from rho\n\nrho_texttr = operatornametr_B rho =  sum_k langle k vert left( sum_ab rho_am bn vert am rangle langle bn vert right)vert k rangle\n\n\n\n\n\n","category":"method"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"CurrentModule=OpenQuantumSystems","category":"page"},{"location":"tutorials/dimer/#Dimer-examples-1","page":"Dimer","title":"Dimer examples","text":"","category":"section"},{"location":"tutorials/dimer/#Simple-example-1","page":"Dimer","title":"Simple example","text":"","category":"section"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"Running the basics dimer with ultra-fast laser excitation.","category":"page"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"using Plots\nusing LaTeXStrings\nusing OpenQuantumSystems\n\nHR = 0.01\nshift = (2.0 * HR)^0.5\nmode = Mode(300., shift)\nmols = [\n    Molecule([mode], 5, [12500., 12750.]),\n    Molecule([mode], 5, [12500., 12800.])\n]\n\nagg = Aggregate(mols)\n# 1 is for el. ground state\nagg.coupling[2, 3] = 100\nagg.coupling[3, 2] = 100\n\naggInds, vibindices, aggIndLen, basis, FCFact, FCProd, Ham, Ham_0, Ham_I = \n    setupAggregate(agg; verbose=false)\n\nT = 100 # temperature\nW0 = thermal_state_composite(T, [0.0, 0.5, 0.5], Ham, aggInds) # laser excitation\nt_max = 0.2\nt_count = 250\ntspan=[0.0:t_max/t_count:t_max;]\ntspan, W_t = evolution_approximate(W0, tspan, Ham)\nrho_tr_t = zeros(ComplexF64, length(tspan), 2, 2)\nfor t_i in 1:length(tspan)\n    rho_tr_t[t_i, :, :] = trace_bath(W_t[t_i].data, agg, FCProd, aggInds, vibindices)\nend\n\nplot(tspan, real(rho_tr_t[:, 1, 1]), label=L\"\\rho_{11}\")\nplot!(tspan, real(rho_tr_t[:, 2, 2]), label=L\"\\rho_{22}\", \n    ylim=(0.0,1.0), ylabel=L\"\\rho_{nn}\", xlabel=L\"t\\:\\:\\mathrm{(a.u.)}\")","category":"page"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"(Image: dimer simple)","category":"page"},{"location":"tutorials/dimer/#Local-vs-exciton-basis-1","page":"Dimer","title":"Local vs exciton basis","text":"","category":"section"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"Running the basics dimer with ultra-fast laser excitation.","category":"page"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"using ProgressMeter\nusing Plots\nusing LaTeXStrings\nusing OpenQuantumSystems\n\nHR = 0.01\nshift = (2.0 * HR)^0.5\nmode = Mode(300., shift)\nmols = [\n    Molecule([mode], 5, [12500., 12750.]),\n    Molecule([mode], 5, [12500., 12800.])\n]\n\nagg = Aggregate(mols)\n# 1 is for el. ground state\nagg.coupling[2, 3] = 100\nagg.coupling[3, 2] = 100\n\naggInds, vibindices, aggIndLen, basis, FCFact, FCProd, Ham, Ham_0, Ham_I = \n    setupAggregate(agg; verbose=false)\n\nHam_sys = getAggHamiltonianSystem(agg; groundState = false)\nHam_sys_lambda, Ham_sys_S = eigen(Ham_sys.data)\nHam_sys_Sinv = inv(Ham_sys_S)\nHam_sys_lambda = diagm(Ham_sys_lambda)\n\nT = 100 # temperature\nW0 = thermal_state_composite(T, [0.0, 0.5, 0.5], Ham, aggInds) # laser excitation\n\nt_max = 0.2\nt_count = 500\ntspan=[0.0:t_max/t_count:t_max;]","category":"page"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"Calculating dynamics in local basis.","category":"page"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"rho_tr_t = zeros(ComplexF64, length(tspan), 2, 2)\nt_i = 0\nt_step = tspan[2] - tspan[1]\nU_op_step = evolutionOperator(Ham, t_step)\nU_op_step_d = U_op_step'\nW = deepcopy(W0)\np = Progress(t_count, barglyphs=BarGlyphs(\"[=> ]\"), barlen=50)\nfor t_i in 1:length(tspan)\n    rho_traced = trace_bath(W.data, agg, FCProd, aggInds, vibindices; groundState=false)\n    rho_tr_t[t_i, :, :] = rho_traced\n    W = U_op_step * W * U_op_step_d\n    ProgressMeter.next!(p)\nend\n\nplot(tspan, real(rho_tr_t[:, 1, 1]), label=L\"\\rho_{11}\")\nplot!(tspan, real(rho_tr_t[:, 2, 2]), label=L\"\\rho_{22}\", \n    ylim=(0.0,1.0), ylabel=L\"\\rho_{nn}\", xlabel=L\"t\\:\\:\\mathrm{(a.u.)}\")","category":"page"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"(Image: dimer simple)","category":"page"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"Calculating dynamics in exciton basis.","category":"page"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"rho_tr_t = zeros(ComplexF64, length(tspan), 2, 2)\nt_i = 0\nt_step = tspan[2] - tspan[1]\nU_op_step = evolutionOperator(Ham, t_step)\nU_op_step_d = U_op_step'\nW = deepcopy(W0)\np = Progress(t_count, barglyphs=BarGlyphs(\"[=> ]\"), barlen=50)\nfor t_i in 1:length(tspan)\n    rho_traced = trace_bath(W.data, agg, FCProd, aggInds, vibindices; groundState=false)\n    rho_traced = Ham_sys_Sinv * rho_traced * Ham_sys_S\n    rho_tr_t[t_i, :, :] = rho_traced\n    W = U_op_step * W * U_op_step_d\n    ProgressMeter.next!(p)\nend\n\nplot(tspan, real(rho_tr_t[:, 1, 1]), label=L\"\\rho_{11}\")\nplot!(tspan, real(rho_tr_t[:, 2, 2]), label=L\"\\rho_{22}\", \n    ylim=(0.0,1.0), ylabel=L\"\\rho_{nn}\", xlabel=L\"t\\:\\:\\mathrm{(a.u.)}\")","category":"page"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"(Image: dimer simple)","category":"page"},{"location":"tutorials/dimer/#Animating-density-matrix-1","page":"Dimer","title":"Animating density matrix","text":"","category":"section"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"Plotting the diagonal of bath part of density matrix.","category":"page"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"W_bath_t = zeros(ComplexF64, length(tspan), aggIndLen, aggIndLen)\nt_i = 0\nt_step = tspan[2] - tspan[1]\nU_op_step = evolutionOperator(Ham, t_step)\nU_op_step_d = U_op_step'\nW = deepcopy(W0)\np = Progress(t_count, barglyphs=BarGlyphs(\"[=> ]\"), barlen=50)\nfor t_i in 1:length(tspan)\n    W_bath = get_rho_bath(W.data, agg, FCProd, aggInds, vibindices; \n        groundState = false, justCopy=false)\n    W_bath_t[t_i, :, :] = W_bath\n    W = U_op_step * W * U_op_step_d\n    ProgressMeter.next!(p)\nend\n\nplot(tspan, real(W_bath_t[:, 1, 1]), label=L\"\\rho_{\\mathrm{B,}11}\")\nprintln(aggIndLen)\nfor i in 2:(length(vibindices[2]) - 1)\n    plot!(tspan, real(W_bath_t[:, i, i]), label=L\"\\rho_{\\mathrm{B,}%$i%$i}\")\nend\ni = length(vibindices[2])\nplot!(tspan, real(W_bath_t[:, i, i]), \n    label=L\"\\rho_{\\mathrm{B,}%$i%$i}\", ylim=(0.0,1.0), ylabel=L\"\\rho_{nn}\", \n    xlabel=L\"t\\:\\:\\mathrm{(a.u.)}\")","category":"page"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"(Image: dimer simple)","category":"page"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"p = Progress(t_count, barglyphs=BarGlyphs(\"[=> ]\"), barlen=50)\nanim = @animate for i = 1:length(tspan)\n    h_re = heatmap(real(rho_bath_t[i, :, :]), \n        aspect_ratio=:equal, title=\"Re \" * lpad(i, 4, \"0\"), c=:magma, clim=(-1.0,1.0))\n    h_im = heatmap(imag(rho_bath_t[i, :, :]), \n        aspect_ratio=:equal, title=\"Im\" * lpad(i, 4, \"0\"), c=:magma, clim=(-1.0,1.0))\n    ProgressMeter.next!(p)\n    plot(h_re, h_im, layout = (1, 2), legend = false, axis = nothing)\nend\n \ngif(anim, fps = 30)","category":"page"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"(Image: dimer simple)","category":"page"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"Plotting the diagonal of density matrix.","category":"page"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"W_t = zeros(ComplexF64, length(tspan), aggIndLen, aggIndLen)\nt_i = 0\nt_step = tspan[2] - tspan[1]\nU_op_step = evolutionOperator(Ham, t_step)\nU_op_step_d = U_op_step'\nW = deepcopy(W0)\np = Progress(t_count, barglyphs=BarGlyphs(\"[=> ]\"), barlen=50)\nfor t_i in 1:length(tspan)\n    W_t[t_i, :, :] = W.data\n    W = U_op_step * W * U_op_step_d\n    ProgressMeter.next!(p)\nend\n\nplot(tspan, real(W_t[:, 1, 1]), label=L\"\\rho_{\\mathrm{B,}11}\")\nprintln(aggIndLen)\nfor i in 2:(length(vibindices[2]) - 1)\n    plot!(tspan, real(W_t[:, i, i]), label=L\"\\rho_{\\mathrm{B,}%$i%$i}\")\nend\ni = length(vibindices[2])\nplot!(tspan, real(W_t[:, i, i]), \n    label=L\"\\rho_{\\mathrm{B,}%$i%$i}\", ylim=(0.0,1.0), ylabel=L\"\\rho_{nn}\", \n    xlabel=L\"t\\:\\:\\mathrm{(a.u.)}\")","category":"page"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"(Image: dimer simple)","category":"page"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"p = Progress(t_count, barglyphs=BarGlyphs(\"[=> ]\"), barlen=50)\nanim = @animate for i = 1:length(tspan)\n    h_re = heatmap(real(W_t[i, :, :]), \n        aspect_ratio=:equal, title=\"Re \" * lpad(i, 4, \"0\"), c=:magma, clim=(-1.0,1.0))\n    h_im = heatmap(imag(W_t[i, :, :]), \n        aspect_ratio=:equal, title=\"Im\" * lpad(i, 4, \"0\"), c=:magma, clim=(-1.0,1.0))\n    ProgressMeter.next!(p)\n    plot(h_re, h_im, layout = (1, 2), legend = false, axis = nothing)\nend\n \ngif(anim, fps = 30)","category":"page"},{"location":"tutorials/dimer/#","page":"Dimer","title":"Dimer","text":"(Image: dimer simple)","category":"page"}]
}
